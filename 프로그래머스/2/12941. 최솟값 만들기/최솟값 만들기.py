# 아니 이건 수학 문제잖슴
def solution(A,B):
    A.sort()  # 오름차순 정렬
    B.sort(reverse=True)  # 내림차순 정렬
    
    return sum(x * y for x, y in zip(A, B))

    return answer

# 수학적인 해결을... 물어봐서 해결했음 쏘리
# 두 리스트 A와 B가 있고, 각각 n개의 원소를 가지고 있다고 가정해봅시다.
# 1. 수학적 표현: 우리가 최소화하려는 것은 다음 식입니다: S = a₁b₁ + a₂b₂ + ... + aₙbₙ 여기서 aᵢ는 A의 원소, bᵢ는 B의 원소입니다.
# 2. 재배열 부등식(Rearrangement Inequality): 이 문제의 핵심은 재배열 부등식입니다. 이 부등식은 다음과 같이 설명됩니다:
#    x₁ ≤ x₂ ≤ ... ≤ xₙ 이고 y₁ ≤ y₂ ≤ ... ≤ yₙ 일 때, x₁y₁ + x₂y₂ + ... + xₙyₙ ≥ x₁yₙ + x₂yₙ₋₁ + ... + xₙy₁
# 3. 최소값 증명:
#    * A를 오름차순으로 정렬: a₁ ≤ a₂ ≤ ... ≤ aₙ
#    * B를 내림차순으로 정렬: b₁ ≥ b₂ ≥ ... ≥ bₙ
#    재배열 부등식에 따라, 이렇게 정렬된 상태에서의 곱의 합이 최소가 됩니다.
# 4. 반증법: 만약 이 배열이 최소가 아니라고 가정해봅시다. 그렇다면 어떤 두 쌍 (aᵢ, bᵢ)와 (aⱼ, bⱼ)를 교환하면 더 작은 합을 얻을 수 있어야 합니다.
#    그러나: aᵢbᵢ + aⱼbⱼ ≤ aᵢbⱼ + aⱼbᵢ (aᵢ ≤ aⱼ 이고 bᵢ ≥ bⱼ 이므로) 이는 어떤 교환도 합을 더 작게 만들 수 없다는 것을 의미합니다.
# 5. 직관적 설명:
#    * 가장 작은 a와 가장 큰 b를 곱하면, 큰 수의 영향을 최소화할 수 있습니다.
#    * 반대로, 비슷한 크기의 수를 곱하면 결과가 더 커집니다.